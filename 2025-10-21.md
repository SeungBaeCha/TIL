# [Unity] 배열 (Array)

## 1. 학습 날짜
2025년 10월 21일

## 2. 학습 내용
- 배열 (Array)



## 3. 왜 중요할까?
- **코드의 단순화**: 비슷한 데이터를 가진 변수들을 일일이 선언할 필요 없이, 하나의 이름으로 묶어서 관리할 수 있어 코드가 훨씬 깔끔하고 짧아진다.
- **데이터 그룹화**: 점수 목록, 몬스터 목록, 아이템 목록처럼 서로 관련된 데이터들을 하나의 그룹으로 묶어두면 논리적으로 이해하기 쉽고 다루기 편하다.
- **반복문과의 시너지**: 배열은 `for`문이나 `foreach`문과 함께 사용할 때 진가를 발휘한다. 배열의 모든 요소에 특정 작업을 반복적으로 적용하기 매우 편리하다.



## 4. 핵심 정리
- **배열이란?**: **같은 타입**의 데이터 여러 개를 **연속된 공간**에 저장하는 자료구조.
- **배열의 특징**:
    1.  **고정된 크기**: 배열은 한 번 생성되면 크기를 바꿀 수 없다. (예: 10칸짜리 배열을 만들면, 11번째 데이터를 추가할 수 없다.)
    2.  **같은 데이터 타입**: `int` 배열에는 정수만, `string` 배열에는 문자열만 담을 수 있다.
    3.  **인덱스 (Index)**: 배열의 각 칸은 `0`부터 시작하는 번호를 가진다. 이 번호를 사용해 특정 위치의 데이터에 접근할 수 있다.

---

#### 코드 예시

**1. 배열 선언과 초기화**

```csharp
// 1-1. 배열 선언 후, 각 인덱스에 값 할당 (가장 기본적인 방법)
// 10개의 정수(int)를 담을 수 있는 배열 scores를 만든다.
int[] scores = new int[10];

// 각 인덱스에 점수 할당
scores[0] = 90;
scores[1] = 45;
// ...
scores[9] = 35;

// 1-2. 선언과 동시에 값 할당 (더 간결한 방법)
int[] scores2 = new int[] { 90, 45, 60, 75, 80, 95, 100, 25, 10, 35 };

// 1-3. new int[] 생략 (가장 짧은 방법)
int[] scores3 = { 90, 45, 60, 75, 80, 95, 100, 25, 10, 35 };

// Unity에서 게임 오브젝트 배열도 자주 사용한다.
// 예를 들어, 맵에 있는 모든 적(Enemy)들을 담아둘 수 있다.
GameObject[] enemies = new GameObject[5];
```

**2. 배열 데이터 접근**

```csharp
// 인덱스는 0부터 시작한다는 점을 꼭 기억해야 한다.
// scores 배열의 4번째 요소(인덱스 3)에 접근하려면,
Debug.Log(scores[3]); // 결과: 75

// 잘못된 인덱스 접근 시 오류 발생
// scores는 0~9번 인덱스만 가지고 있다.
// Debug.Log(scores[10]); // IndexOutOfRangeException 오류 발생!
```

**3. 배열과 반복문 활용**

```csharp
// for문을 사용하면 배열의 모든 요소를 순회할 수 있다.
// 이 때, 배열의 크기를 직접 쓰는 것(10)보다 '배열이름.Length' 속성을 사용하는 것이 훨씬 좋다.
// 나중에 배열 크기가 바뀌어도 코드를 수정할 필요가 없기 때문이다.
for(int i = 0; i < scores.Length; i++)
{
    Debug.Log((i + 1) + "번째 학생의 점수는 " + scores[i]);
}

// foreach문은 더 간결하게 배열의 모든 요소를 순회할 수 있다.
// 배열의 모든 아이템을 한 번씩 꺼내서 사용할 때 유용하다.
foreach(int score in scores)
{
    Debug.Log("이번 학생의 점수: " + score);
}
```

**4. 배열의 한계**

```csharp
int[] originalScores = new int[10];
// ... (값을 채웠다고 가정)

// 만약 더 많은 공간이 필요해서 배열 크기를 바꾸고 싶다면?
// 기존 배열의 크기를 직접 늘릴 수는 없다.
// 더 큰 새 배열을 만들고, 기존 데이터를 복사해야 한다.
int[] newScores = new int[20];
for(int i = 0; i < originalScores.Length; i++)
{
    newScores[i] = originalScores[i];
}

// 또는, 아래와 같이 선언하면 기존 데이터는 모두 사라지고,
// 20개의 0으로 채워진 새로운 배열이 scores 변수를 덮어쓴다.
// originalScores = new int[20];
```
> 이처럼 크기 변경이 번거롭기 때문에, 데이터의 개수가 자주 변하는 경우에는 배열보다 **리스트(List)**를 사용하는 것이 더 효율적이다.




## 5. 어려웠던 점 & 해결 과정
**문제:**
처음에는 여러 개의 변수를 사용하는 것과 배열의 차이점이 명확하게 와닿지 않았고, 언제 사용해야 효율적인지 판단하기 어려웠다.

**해결:**
점수 목록이나 몬스터 목록처럼, **성격이 같고 반복적으로 처리해야 할 데이터들**이 보일 때 배열로 묶어보니 코드가 훨씬 간결해지고 관리하기 편해지는 것을 직접 경험했다. 특히 `for`문으로 배열 전체를 한 번에 처리할 수 있다는 점이 가장 큰 장점으로 느껴졌다.

## 6. 참고 자료
- **[유튜브] 레트로 retr0 - C# 배열**: [https://www.youtube.com/watch?v=gqZdPRmdGzk&list=PLctzObGsrjfyKVZol-aPl-2c9cLAQHzKq&index=10]
- **Unity 공식 문서 - Arrays**: [(https.learn.unity.com/tutorial/arrays)
- **C# 가이드 - 배열**: (https://learn.microsoft.com/ko-kr/dotnet/csharp/programming-guide/arrays/)
