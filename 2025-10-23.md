# [Unity] Linked List (연결리스트) (1)

## 1. 학습 날짜
2025년 10월 23일

## 2. 학습 내용
- Linked List의 기본개념
- Linked List의 연결방식 (단방향)



## 3. 왜 중요할까?


**배열(Array)의 한계를 보완하기 위해서 중요하다.**

우리가 흔히 쓰는 배열(`int[] arr = new int[5]`)은 아파트와 같다. 각 방(인덱스)에 바로 찾아갈 수 있어서 **조회 속도가 매우 빠르다(O(1))**. 502호에 가고 싶으면 바로 502호로 가면 되기 때문이다.

하지만 배열은 중간에 데이터를 **추가하거나 삭제하기가 아주 번거롭다(O(n))**. 502호 주민이 이사 가서 방을 빼야 한다면, 그 뒤에 사는 503호, 504호... 모든 주민이 한 칸씩 앞으로 이사 와야 한다. 반대로 중간에 누가 이사 오면 모든 주민이 한 칸씩 뒤로 밀려나야 한다. 데이터가 많을수록 이런 작업은 엄청난 비용이 발생한다.


**연결 리스트는 기차와 같다.** 각 칸(노드)이 다음 칸의 정보(Next)를 가지고 줄줄이 연결된 형태이다.
**추가/삭제가 매우 빠르다(O(1))**. 중간에 있는 B칸을 빼고 싶으면, A칸이 C칸을 가리키게 연결만 바꿔주면 끝이다. 다른 칸들은 움직일 필요가 전혀 없다.




- **결론:** 데이터의 **추가/삭제가 빈번하게 일어나는 상황**에서는 배열보다 연결 리스트가 훨씬 효율적이다. 어떤 데이터를 어떻게 다룰지에 따라 배열을 쓸지, 연결 리스트를 쓸지 결정하는 능력이 중요하다.





## 4. 핵심 정리



- **노드(Node)**: 연결 리스트를 구성하는 기본 블록. **데이터(Data)**와 **다음 노드를 가리키는 참조(Next)**, 두 가지를 가진다.


- **참조(Reference) / 포인터(Pointer)**: 노드들을 연결하는 '연결 고리'. C#에서는 '참조'라고 부른다. 이 참조가 연결 리스트의 핵심이다.


- **Head**: 리스트의 가장 첫 번째 노드. 기차의 기관차 같은 역할이다. Head를 잃어버리면 전체 리스트를 찾을 수 없다.

- **Tail**: 리스트의 가장 마지막 노드. 이 노드의 `Next` 참조는 `null`이다. (다음 칸이 없다는 뜻)



- **단방향(Singly)**: 기차처럼 앞에서 뒤로만 갈 수 있는 구조로, `Next` 참조만 가진다.
- **양방향(Doubly)**: 지하철처럼 앞뒤로 다 갈 수 있는 구조로, `Next`(다음)와 `Prev`(이전) 참조를 모두 가진다.


### 코드 예시 (주석 및 서식 수정)



```csharp
using System;

// C#에서는 클래스, 메서드, 프로퍼티 이름을 보통 대문자로 시작한다. (파스칼 케이스)
public class Node
{
    // 필드(field) 대신 프로퍼티(Property)를 사용하는 것이 C#의 표준 스타일이다.
    // { get; set; }을 통해 외부에서 값을 읽고 쓸 수 있게 한다.
    public int Data { get; set; }
    public Node Next { get; set; } // 다음 노드를 가리키는 참조

    // 생성자: 노드가 처음 만들어질 때 데이터를 저장한다.
    public Node(int data)
    {
        this.Data = data;
        this.Next = null; // 처음에는 다음 노드가 없으므로 null로 초기화한다.
    }

    // 리스트의 끝에 새로운 노드를 추가하는 메서드
    public void Append(int data)
    {
        Node end = new Node(data);
        Node n = this; // 'this'는 이 메서드를 호출한 객체(여기서는 head)를 의미한다.

        // n.Next가 null이 아닐 동안, 즉 마지막 노드가 아닐 동안 계속 반복한다.
        while (n.Next != null)
        {
            n = n.Next; // 다음 노드로 한 칸씩 이동한다.
        }
        // while문이 끝나면 n은 리스트의 마지막 노드가 된다.
        // 마지막 노드의 Next에 새로 만든 노드(end)를 연결한다.
        n.Next = end;
    }

    // 특정 데이터를 가진 노드를 삭제하는 메서드
    public void Delete(int data)
    {
        Node n = this;

        // '다음' 노드가 있는지 확인하며 반복한다.
        while (n.Next != null)
        {
            // 만약 '다음' 노드의 데이터가 삭제할 데이터와 같다면
            if (n.Next.Data == data)
            {
                // '현재' 노드(n)의 다음 연결을 '다다음' 노드로 바꿔버린다.
                // (n) -> (n.Next) -> (n.Next.Next)  ==>  (n) -> (n.Next.Next)
                // 이렇게 하면 중간에 있던 n.Next 노드는 연결이 끊어져 사실상 삭제된다.
                n.Next = n.Next.Next;
            }
            else
            {
                // 삭제할 데이터가 아니라면, 현재 노드를 다음 노드로 이동시킨다.
                n = n.Next;
            }
        }
    }

    // 리스트의 모든 데이터를 순서대로 출력하는 메서드
    public void Retrieve()
    {
        Node n = this;
        while (n.Next != null)
        {
            // C#에서는 Console.Write()를 사용해 화면에 글자를 출력한다.
            Console.Write(n.Data + " -> ");
            n = n.Next;
        }
        // 마지막 노드의 데이터를 출력한다.
        Console.WriteLine(n.Data); // WriteLine은 출력 후 줄을 바꿔준다.
    }
}

// Main 메서드를 포함할 실행용 클래스
public class SinglyLinkedList
{
    // C# 프로그램의 시작점은 Main 메서드이다.
    public static void Main(string[] args)
    {
        // 1. 노드의 시작점(head)을 만들고 데이터 '1'을 저장한다.
        Node head = new Node(1);

        // 2. Append 메서드로 리스트 끝에 노드를 계속 추가한다.
        head.Append(2);
        head.Append(3);
        head.Append(4);
        // 현재 리스트 상태: 1 -> 2 -> 3 -> 4

        // 3. Retrieve 메서드로 현재까지의 리스트를 출력한다.
        Console.WriteLine("--- 삭제 전 리스트 ---");
        head.Retrieve(); // 출력: 1 -> 2 -> 3 -> 4

        // 4. Delete 메서드로 데이터가 '3'인 노드를 삭제한다.
        head.Delete(3);
        // 삭제 후 리스트 상태: 1 -> 2 -> 4

        // 5. 삭제 후의 리스트를 다시 출력해서 확인한다.
        Console.WriteLine("
--- 데이터 3 삭제 후 리스트 ---");
        head.Retrieve(); // 출력: 1 -> 2 -> 4
    }
}


```
## 5. 어려웠던 점 & 해결 과정

**문제:**
강의가 Java 기반이라 C#으로 개념을 적용하기 헷갈렸다. 특히 C++의 '포인터' 개념이 C#의 '참조'와 어떻게 다른지, `Delete` 메서드에서 노드의 연결을 끊는 부분이 머릿속에 잘 그려지지 않았다.

**해결:**
C# 코드로 직접 한 줄씩 바꿔보면서 개념을 다시 정리했다. `n.Next = n.Next.Next` 코드가 메모리에서 뭔가를 직접 지우는 게 아니라는 걸 깨달았다. 그냥 **A노드가 B를 건너뛰고 C노드를 가리키도록 '연결 고리'만 바꿔 끼우는 과정**임을 그림으로 그려보며 이해했다.

이렇게 연결이 끊어져 외톨이가 된 B노드는, C#의 **가비지 컬렉터(GC, 쓰레기 수집가)**가 "어? 얘 아무도 연결 안 하네?"라고 발견하고 나중에 알아서 메모리에서 치워준다는 사실을 알게 되었다. 포인터를 직접 관리하지 않는 C#의 방식이 훨씬 안전하고 편하다는 걸 느꼈다.

## 6. 참고 자료
- **[유튜브] 엔지니어 대한민국 - 단방향 LinkedList 구현** : https://www.youtube.com/watch?v=C1SDkdPvQPA