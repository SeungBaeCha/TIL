 # [Unity] 게임오브젝트와 컴포넌트

## 1. 학습 날짜
2025년 10월 13일


## 2. 학습 내용

게임오브젝트(GameObject)와 컴포넌트(Component)의 개념
컴포넌트 기반 설계(Component-Based Design)의 이해


## 3. 왜 중요할까?


유니티의 모든 것은 게임오브젝트와 컴포넌트로 이루어져 있다. 이 둘의 관계를 이해하는 것이 유니티
개발의 가장 기초이자 핵심이라고 생각하여 학습했다.


**게임오브젝트:** '그릇' 또는 '뼈대'. 씬(Scene)에 존재할 수 있는 모든 개체의 기본 단위.
그 자체만으로는 아무 기능이 없다.

**컴포넌트:** '내용물' 또는 '부품'. 게임오브젝트에 붙어서 실제 기능을 수행한다. 
(예: `Transform`, `Rigidbody`, `Collider`, 스크립트 등)

**핵심은 '조립'이다.** 필요한 기능(컴포넌트)들을 빈 게임오브젝트에 조립하여 
원하는 하나의 '캐릭터', '총알', '벽' 등을 만들어내는 방식이다. 

각 부품은 독립적으로 설계되어 있어 재사용이 쉽고 유연한 개발이 가능하다.




## 4. 핵심 정리


유니티 개발은 수학/물리 공식을 직접 구현하는 것이 아니라, 

**유니티가 제공하는 `Rigidbody`같은 물리 부품(컴포넌트)을 가져와 '어떻게 잘 조립하고, 
언제 어떤 명령을 내릴지'를 결정하는 것**  이다.

게임 로직을 담는 **C# 스크립트 또한 하나의 컴포넌트**다. 이 스크립트 컴포넌트가 다른
컴포넌트들에게 명령을 내리는 '지휘자' 역할을 주로 수행한다.


컴포넌트 간의 소통은 `BroadcastMessage` 같은 옛날 방식이 아닌,
**필요한 컴포넌트를 변수에직접 참조(연결)하여 명확하게 호출하는 방식**을 사용한다.




#### 코드 예시 (C#)

using UnityEngine;

// Jumper라는 이름의 새로운 컴포넌트(스크립트)를 정의

public class Jumper : MonoBehaviour
{

    // Rigidbody 컴포넌트를 연결할 변수.
    // [SerializeField]를 쓰면 private이면서도 유니티 에디터에서 보이기 때문에 더 안전하다.

    [SerializeField] 
    private Rigidbody rigid;

    // 게임이 시작될 때 한 번 호출되는 함수
    void Start()
    {
        // 연결된 Rigidbody 컴포넌트에게 AddForce 기능을 사용하라고 직접 명령
        // Vector3.up은 (0, 1, 0)과 같다. Y축(위쪽) 방향으로 100의 힘을 가함.
    rigid.AddForce(Vector3.up * 100);
    }
    
}



## 5. 어려웠던 점 & 해결 과정


**문제:** 

처음에는 스크립트에서 어떻게 `Rigidbody`의 점프 기능을 가져다 쓰는지 막막했다.
스크립트와 컴포넌트가 완전히 별개라고 생각했다.


**해결:** 

C# 스크립트도 하나의 컴포넌트이며, `public`이나 `[SerializeField]` 키워드를 사용해
다른 컴포넌트를 변수에 담아 직접 참조할 수 있다는 것을 알게 되었다. 
마치 스크립트가 다른 부품들을 조종할 수 있는 '리모컨' 역할을 한다는 것을 깨달았다.





## 6. 참고 자료

[유튜브] 레트로 retr0 - 게임엔진은 어떻게 동작하나?: (https://www.youtube.com/watch?v=S287iwsU2bE&list=PLctzObGsrjfyKVZol-aPl-2c9cLAQHzKq)
Unity 공식 문서 - Component: (링크 추가 예정)