# [Unity] 객체지향, 클래스와 오브젝트

## 1. 학습 날짜
2025년 10월 22일

## 2. 학습 내용
- 객체지향 프로그래밍(OOP)의 기본 개념
- 클래스(Class)와 오브젝트(Object)의 관계
- 값(Value) 복사와 참조(Reference) 복사의 차이


## 3. 왜 중요할까?

- **현실 세계의 반영:** 우리가 만드는 게임 속 세상은 수많은 '객체'(캐릭터, 몬스터, 아이템 등)로 이루어져 있다. 객체지향은 이 객체들을 코드로 쉽게 표현하고 관리할 수 있게 해주는 강력한 도구다.

- **코드의 재사용과 유지보수:** 잘 만들어진 '클래스(설계도)' 하나만 있으면, 비슷한 '오브젝트(객체)'들을 계속해서 찍어낼 수 있다. 예를 들어, '슬라임' 클래스 하나로 수십 마리의 슬라임 몬스터를 만들 수 있고, 나중에 슬라임의 공격력을 바꿔야 할 때도 '슬라임' 클래스 하나만 수정하면 모든 슬라임에게 적용되니 관리가 매우 편해진다.



## 4. 핵심 정리

클래스 (Class) - "붕어빵 틀"
- **정의:** 객체를 만들기 위한 **설계도** 또는 **원형(Blueprint)**.
- **특징:**
    - 눈에 보이지 않는 '개념'의 영역이다.
    - 객체가 어떤 데이터(속성, 예: 이름, 체력, 공격력)와 어떤 기능(메서드, 예: 공격하기, 이동하기)을 가질지 정의한다.
    - 클래스 자체는 구체적인 값을 가지지 않는다. '캐릭터'는 '체력'을 가진다고 정의할 뿐, 그 체력이 '100'이라고 정해두진 않는다.

오브젝트 (Object) - "붕어빵"
- **정의:** 클래스라는 설계도를 바탕으로 **실제로 만들어진 실체**.
- **특징:**
    - 메모리 상에 공간을 차지하는, 눈에 보이는 '실체'의 영역이다.
    - 클래스에서 정의한 속성과 기능을 그대로 물려받는다.
    - 각 오브젝트는 서로 다른 속성 값을 가질 수 있는 **독립적인 존재**다. (예: 똑같은 '슬라임' 클래스로 만들어도, '파란 슬라임'과 '빨간 슬라임'은 서로 다른 오브젝트다.)

인스턴스화 (Instantiation) - "붕어빵 굽기"
- 클래스(설계도)를 사용해서 메모리 상에 실제 오브젝트(객체)를 만들어내는 과정을 말한다.
- C#에서는 `new` 키워드를 사용해서 인스턴스화를 진행한다.

---


### 코드 예시와 '참조'의 이해



**Animal 클래스 정의 (설계도)**
```csharp
public class Animal
{
    public string name;
    public string sound;
    public float weight;

    public void PrintInfo()
    {
        Debug.Log("이름: " + name + ", 소리: " + sound + ", 무게: " + weight + "kg");
    }
}
```
**오브젝트 생성 및 사용 (실체)**
```csharp
// 1. Animal 클래스를 기반으로 'jack'이라는 오브젝트를 인스턴스화(생성)한다.
Animal jack = new Animal(); 
jack.name = "잭";
jack.sound = "멍멍";
jack.weight = 4.5f;

// 2. 'annie'라는 또 다른 오브젝트를 인스턴스화(생성)한다.
Animal annie = new Animal();
annie.name = "애니";
annie.sound = "야옹";
annie.weight = 3.5f;

jack.PrintInfo();   // 출력: 이름: 잭, 소리: 멍멍, 무게: 4.5kg
annie.PrintInfo();  // 출력: 이름: 애니, 소리: 야옹, 무게: 3.5kg
```




### 심화: 참조(Reference)란 무엇인가?




여기서부터가 정말 중요한 부분이다. C#에서 클래스로 만든 변수(jack, annie)는 **객체 그 자체가 아니라, 메모리 어딘가에 생성된 객체를 가리키는 '리모컨' 또는 '주소'**라고 생각해야 한다.

```csharp
// jack의 리모컨이 annie의 리모컨이 가리키는 대상을 똑같이 가리키게 만든다.
jack = annie; 
```
- 이 코드는 `jack`이라는 객체를 `annie` 객체로 복사하는 게 아니다.
- `jack`이라는 **리모컨**이 원래 가리키던 '잭' 객체 대신, `annie` 리모컨이 가리키던 '애니' 객체를 **똑같이 가리키게** 만든다.
- 이제 '잭' 객체는 아무도 가리키지 않으므로 사라지고(가비지 컬렉터가 처리), `jack`과 `annie` 두 개의 리모컨이 **하나의 '애니' 객체**를 동시에 조종하게 된다.

```csharp
// jack 리모컨으로 이름을 '지미'로 바꾼다.
jack.name = "지미";

// annie 리모컨으로 정보를 확인해본다.
annie.PrintInfo(); // 출력: 이름: 지미, 소리: 야옹, 무게: 3.5kg
jack.PrintInfo();  // 출력: 이름: 지미, 소리: 야옹, 무게: 3.5kg
```
- `jack` 리모컨으로 조종했지만, `annie` 리모컨이 가리키는 대상도 결국 같은 '애니' 객체이므로 이름이 '지미'로 바뀐 것을 확인할 수 있다.
- 이것을 **'참조(Reference)에 의한 할당'**이라고 부른다. 클래스는 참조 타입이기 때문에 이런 현상이 발생한다.



> **참고: 값(Value) 타입**
> `int`, `float`, `bool` 같은 기본 데이터 타입들은 '값 타입'이다. 이들은 리모컨 방식이 아니라, 변수 자체가 값을 직접 가지고 있다. 그래서 `int a = 10; int b = a;` 를 한 뒤 `b = 20;`으로 바꿔도 `a`는 여전히 `10`이다. 서로에게 영향을 주지 않는다.




### 유니티와 MonoBehaviour


- 유니티에서 사용하는 모든 스크립트는 `MonoBehaviour`라는 특별한 클래스를 상속받는다.
- `MonoBehaviour`는 우리가 만든 클래스가 유니티 게임 세상의 오브젝트(컴포넌트)로 존재하며, `Update()`나 `Start()` 같은 유니티의 생명주기 함수를 사용할 수 있게 해주는 연결고리다.




## 5. 핵심 요약



- **클래스**는 설계도, **오브젝트**는 그 설계도로 만든 실체.
- `new`는 클래스를 실제 오브젝트로 만드는 **인스턴스화** 과정이다.
- 클래스 변수는 객체 자체가 아니라 객체를 가리키는 **리모컨(참조)**이다.
- 리모컨을 복사하면, 여러 리모컨이 **하나의 객체**를 함께 조종하게 될 수 있다. 이 개념을 이해하는 것이 객체지향의 핵심 중 하나다.


## 6. 참고 자료
- **[유튜브] 레트로 retr0 - C# 클래스와 오브젝트**: [https://www.youtube.com/watch?v=GwL5uUP7F1Y&list=PLctzObGsrjfyKVZol-aPl-2c9cLAQHzKq&index=11]
