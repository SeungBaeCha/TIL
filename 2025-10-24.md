# [Unity] LinkedList 중복값제거 (2)

## 1. 학습 날짜
2025년 10월 24일

## 2. 학습 내용
- C#을 이용한 연결 리스트 클래스 구현 방식
- 정렬되지 않은 연결 리스트의 중복 값 제거 방법 2가지

## 3. 연결 리스트 클래스 구현
이전에는 `Node` 클래스 자체에 `Append`, `Delete` 같은 기능을 넣었지만, 더 객체지향적인 설계를 위해 **리스트 전체를 관리하는 `LinkedList` 클래스를 만드는 것이 좋다.**

`LinkedList` 클래스는 `header` 노드를 가지고 리스트의 시작점을 가리키며, `Append`, `RemoveDuplicates` 등 리스트를 조작하는 기능들을 메서드로 가진다.

### 문제점: 첫 번째 노드(Head) 삭제의 어려움
만약 리스트의 첫 번째 노드 자체가 값과 다음 노드 참조를 모두 가지는 대표가 되면, 이 노드를 삭제하는 로직이 매우 복잡해진다.

### 해결책: 헤더(Header) 노드 도입
이 문제를 해결하기 위해, 실제 데이터는 가지지 않고 오직 **'리스트의 시작'**이라는 표지판 역할만 하는 `header` 노드를 맨 앞에 둔다. `header.next`가 실질적인 첫 번째 데이터 노드를 가리키게 하는 것이다. 이렇게 하면 첫 번째 데이터 노드를 삭제하더라도 `header`는 그대로 남아있기 때문에 코드가 훨씬 간단하고 안정적이게 된다.

```csharp
// 연결 리스트 전체를 관리하는 클래스
public class LinkedList
{
    // Node 클래스는 LinkedList 안에서만 쓰이므로, 내부 클래스(nested class)로 정의하는 것이 깔끔하다.
    public class Node
    {
        public int data;
        public Node next = null;

        public Node(int d)
        {
            data = d;
        }
    }

    Node header;

    public LinkedList()
    {
        // header는 데이터를 가지지 않는 더미 노드이다.
        header = new Node(0); 
    }

    // 리스트 끝에 노드 추가
    public void Append(int data)
    {
        Node newNode = new Node(data);
        Node current = header;
        while (current.next != null)
        {
            current = current.next;
        }
        current.next = newNode;
    }

    // 리스트 출력
    public void PrintList()
    {
        Node current = header.next; // header 다음 노드부터가 실제 데이터
        while (current != null)
        {
            Console.Write(current.data + " -> ");
            current = current.next;
        }
        Console.WriteLine("null");
    }
}
```

## 4. 정렬되지 않은 연결 리스트에서 중복 값 제거
`3 -> 2 -> 1 -> 2 -> 4` 처럼 정렬되어 있지 않고 중복 값이 있는 리스트에서 `2`를 제거하여 `3 -> 2 -> 1 -> 4`로 만드는 방법을 알아본다.

### 4.1. 방법 1: 버퍼(임시 저장 공간) 사용

**개념:**
`HashSet`이라는 자료구조를 사용한다. `HashSet`은 중복된 값을 저장하지 않는 특징이 있어, 이미 나온 값인지 확인하는 데 매우 효율적이다.

리스트를 처음부터 순회하면서, 각 노드의 데이터를 `HashSet`에 넣어본다.
- `HashSet`에 이미 들어있는 값이면, 그 노드는 중복된 노드이므로 리스트에서 제거한다.
- `HashSet`에 없는 새로운 값이면, `HashSet`에 추가하고 다음 노드로 넘어간다.

**C# 코드 예시:**
```csharp
// LinkedList 클래스 내부에 추가할 메서드
public void RemoveDuplicatesWithBuffer()
{
    // 이미 등장한 데이터들을 저장할 HashSet
    HashSet<int> set = new HashSet<int>();
    
    Node previous = header; // 이전 노드를 추적
    Node current = header.next; // 현재 확인할 노드

    while (current != null)
    {
        // 현재 노드의 데이터가 set에 이미 존재한다면 (중복이라면)
        if (set.Contains(current.data))
        {
            // 이전 노드의 next를 현재 노드의 next로 바꿔서, 현재 노드를 건너뛰게 한다 (삭제 효과)
            previous.next = current.next;
        }
        else
        {
            // 새로운 데이터라면 set에 추가하고, previous를 현재 노드로 업데이트한다.
            set.Add(current.data);
            previous = current;
        }
        // 다음 노드로 이동
        current = current.next;
    }
}
```

- **시간 복잡도: O(N)** - 리스트를 한 번만 순회하면 된다.
- **공간 복잡도: O(N)** - 중복되지 않은 모든 값을 `HashSet`에 저장해야 하므로, 최악의 경우 리스트 크기만큼의 추가 공간이 필요하다.


### 4.2. 방법 2: 버퍼 미사용 (러너 기법)

**개념:**
추가적인 메모리 공간(버퍼)을 사용할 수 없을 때 쓰는 방법이다. 2개의 포인터(러너)를 사용한다.
1.  `current` 포인터는 리스트를 순차적으로 순회한다.
2.  `runner` 포인터는 `current` 포인터가 가리키는 노드부터 리스트의 끝까지 순회하면서, `current` 노드와 중복되는 값을 가진 노드가 있는지 찾는다.
3.  만약 `runner`가 중복된 노드를 발견하면, 그 노드를 리스트에서 제거한다.

**C# 코드 예시:**
```csharp
// LinkedList 클래스 내부에 추가할 메서드
public void RemoveDuplicatesRunner()
{
    Node current = header.next; // 기준이 되는 포인터
    while (current != null)
    {
        Node runner = current; // 리스트를 순회하며 중복을 찾을 포인터
        while (runner.next != null)
        {
            // runner의 다음 노드가 current 노드와 데이터가 같다면 (중복 발견)
            if (runner.next.data == current.data)
            {
                // runner의 다음 연결을 다다음 노드로 바꿔서 중복 노드를 건너뛴다.
                runner.next = runner.next.next;
            }
            else
            {
                // 중복이 아니면 runner를 다음 노드로 이동
                runner = runner.next;
            }
        }
        // 기준 포인터 current를 다음 노드로 이동
        current = current.next;
    }
}
```

- **시간 복잡도: O(N²)** - 외부 루프가 N번, 내부 루프가 평균 N/2번 돌아 2중 반복문 구조를 가진다.
- **공간 복잡도: O(1)** - 포인터 변수 몇 개만 사용하므로 추가적인 저장 공간이 거의 필요 없다.

## 5. 결론: 어떤 방법을 선택해야 할까?
- **메모리 공간에 여유가 있다면 `방법 1 (HashSet)`이 무조건 좋다.** 시간 효율이 훨씬 뛰어나기 때문이다. 대부분의 실제 상황에서는 이 방법을 사용한다.
- **"추가적인 메모리 사용 불가"라는 제약 조건이 있다면 `방법 2 (러너 기법)`를 사용해야 한다.** 코딩 테스트에서 종종 이런 제약 조건을 걸어서 문제 해결 능력을 평가하기도 한다.

## 6. 어려웠던 점 & 해결 과정

**문제:**
강의가 Java 기반이라 C#으로 개념을 적용하기 헷갈렸다. 특히 C++의 '포인터' 개념이 C#의 '참조'와 어떻게 다른지, `Delete` 메서드에서 노드의 연결을 끊는 부분이 머릿속에 잘 그려지지 않았다.

**해결:**
C# 코드로 직접 한 줄씩 바꿔보면서 개념을 다시 정리했다. `n.Next = n.Next.Next` 코드가 메모리에서 뭔가를 직접 지우는 게 아니라는 걸 깨달았다. 그냥 **A노드가 B를 건너뛰고 C노드를 가리키도록 '연결 고리'만 바꿔 끼우는 과정**임을 
그림으로 그려보며 이해했다.

이렇게 연결이 끊어져 외톨이가 된 B노드는, C#의 **가비지 컬렉터(GC, 쓰레기 수집가)**가 "어? 얘 아무도 연결 안 하네?"라고 발견하고 나중에 알아서 메모리에서 치워준다는 사실을 알게 되었다. 
포인터를 직접 관리하지 않는 C#의 방식이 훨씬 안전하고 편하다는 걸 느꼈다.

## 7. 참고 자료
- **[유튜브] 엔지니어 대한민국 - 단방향 LinkedList 구현** : https://www.youtube.com/watch?v=Ce4baygLMz0&t=107s